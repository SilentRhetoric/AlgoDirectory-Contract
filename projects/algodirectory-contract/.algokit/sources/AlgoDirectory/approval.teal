#pragma version 10

// This TEAL was generated by TEALScript v0.100.2
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// checkCallerIsListingOwner(nfdAppID: uint64): void
checkCallerIsListingOwner:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:21
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: uint64
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:22
	// assert(this.txn.sender === this.listings(listingKey).value, 'Caller must be listing owner')
	txn Sender
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	==

	// Caller must be listing owner
	assert
	retsub

// checkNFDIsSegmentOfDirectory(nfdAppID: uint64): void
checkNFDIsSegmentOfDirectory:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:27
	// assert(
	//       btoi(AppID.fromUint64(nfdAppID).globalState('i.parentAppID') as bytes) === 576232821,
	//       'NFD must be a segment of directory.algo with parent app ID 576232821'
	//     )
	frame_dig -1 // nfdAppID: uint64
	byte 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.parentAppID')
	assert
	btoi
	int 576232821
	==

	// NFD must be a segment of directory.algo with parent app ID 576232821
	assert
	retsub

// checkCallerIsNFDOwner(nfdAppID: uint64): void
checkCallerIsNFDOwner:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:35
	// assert(
	//       this.txn.sender === (AppID.fromUint64(nfdAppID).globalState('i.owner.a') as Address),
	//       'Listing creator must be the NFD app i.owner.a'
	//     )
	txn Sender
	frame_dig -1 // nfdAppID: uint64
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.owner.a')
	assert
	==

	// Listing creator must be the NFD app i.owner.a
	assert
	retsub

// checkNFDNotExpired(nfdAppID: uint64): void
checkNFDNotExpired:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:43
	// assert(
	//       globals.latestTimestamp <= btoi(AppID.fromUint64(nfdAppID).globalState('i.expirationTime') as bytes),
	//       'NFD segment must not be expired'
	//     )
	global LatestTimestamp
	frame_dig -1 // nfdAppID: uint64
	byte 0x692e65787069726174696f6e54696d65 // "i.expirationTime"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.expirationTime')
	assert
	btoi
	<=

	// NFD segment must not be expired
	assert
	retsub

// getRoundedTimestamp(): uint64
getRoundedTimestamp:
	proto 0 1

	// contracts/AlgoDirectory.algo.ts:50
	// return btoi(replace3(itob(globals.latestTimestamp), 7, bzero(1)));
	global LatestTimestamp
	itob
	byte 0x00
	replace2 7
	btoi
	retsub

// createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
*abi_route_createListing:
	// The ABI return prefix
	byte 0x151f7c75

	// listingTags: byte[13]
	txna ApplicationArgs 2
	dup
	len
	int 13
	==

	// argument 0 (listingTags) for createListing must be a byte[13]
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// collateralPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 2 (collateralPayment) for createListing must be a pay transaction
	assert

	// execute createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
	callsub createListing
	concat
	log
	int 1
	return

// createListing(collateralPayment: PayTxn, nfdAppID: uint64, listingTags: StaticArray<byte, 13>): Listing
//
// Creates a listing in the directory by vouching for an NFD root or segment of directory.algo.
//
// @param nfdAppID The uint64 application ID of the NFD that will be listed
// @param collateralPayment The Algo payment of collateral to vouch for the listing
createListing:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/AlgoDirectory.algo.ts:61
	// verifyPayTxn(collateralPayment, {
	//       sender: this.txn.sender,
	//       receiver: this.app.address,
	//       amount: { greaterThan: TOTAL_LISTING_BOXES_COST },
	//     })
	// verify sender
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"sender","expected":"this.txn.sender"}
	assert

	// verify receiver
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	int 72200
	>

	// transaction verification failed: {"txn":"collateralPayment","field":"amount","condition":"greaterThan","expected":">TOTAL_LISTING_BOXES_COST"}
	assert

	// contracts/AlgoDirectory.algo.ts:68
	// this.checkNFDIsSegmentOfDirectory(nfdAppID)
	frame_dig -2 // nfdAppID: uint64
	callsub checkNFDIsSegmentOfDirectory

	// contracts/AlgoDirectory.algo.ts:69
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -2 // nfdAppID: uint64
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:70
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -2 // nfdAppID: uint64
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:73
	// nfdLongName = AppID.fromUint64(nfdAppID).globalState('i.name') as bytes
	frame_dig -2 // nfdAppID: uint64
	byte 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppID).globalState('i.name')
	assert
	frame_bury 0 // nfdLongName: byte[]

	// contracts/AlgoDirectory.algo.ts:75
	// sendAppCall({
	//       applicationID: AppID.fromUint64(84366825), // Mainnet 760937186
	//       applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)],
	//       fee: 0,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:76
	// applicationID: AppID.fromUint64(84366825)
	int 84366825
	itxn_field ApplicationID

	// contracts/AlgoDirectory.algo.ts:77
	// applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)]
	byte 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig 0 // nfdLongName: byte[]
	itxn_field ApplicationArgs
	frame_dig -2 // nfdAppID: uint64
	itob
	itxn_field ApplicationArgs

	// contracts/AlgoDirectory.algo.ts:78
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:80
	// assert(btoi(this.itxn.lastLog) === 1, 'NFD app ID must be valid at the NFD registry')
	itxn LastLog
	btoi
	int 1
	==

	// NFD app ID must be valid at the NFD registry
	assert

	// contracts/AlgoDirectory.algo.ts:83
	// assert(!this.listedNFDappIDs(nfdAppID).exists, 'Listing for this NFD must not already exist')
	frame_dig -2 // nfdAppID: uint64
	itob
	box_len
	swap
	pop
	!

	// Listing for this NFD must not already exist
	assert

	// contracts/AlgoDirectory.algo.ts:86
	// nfdSegmentName = substring3(nfdLongName, 0, len(nfdLongName) - 15)
	frame_dig 0 // nfdLongName: byte[]
	int 0
	frame_dig 0 // nfdLongName: byte[]
	len
	int 15
	-
	substring3
	frame_bury 1 // nfdSegmentName: byte[]

	// contracts/AlgoDirectory.algo.ts:88
	// listingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: collateralPayment.amount,
	//       nfdAppID: nfdAppID,
	//       tags: listingTags,
	//       name: nfdSegmentName,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0027 // initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // nfdAppID: uint64
	itob
	callsub *process_static_tuple_element
	frame_dig -3 // listingTags: StaticArray<byte, 13>
	callsub *process_static_tuple_element
	frame_dig 1 // nfdSegmentName: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // listingKey: Listing

	// contracts/AlgoDirectory.algo.ts:97
	// this.listings(listingKey).value = this.txn.sender
	frame_dig 2 // listingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:100
	// this.listedNFDappIDs(nfdAppID).value = listingKey
	frame_dig -2 // nfdAppID: uint64
	itob
	dup
	box_del
	pop
	frame_dig 2 // listingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:102
	// return listingKey;
	frame_dig 2 // listingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// refreshListing(uint64)(uint64,uint64,uint64,byte[13],string)
*abi_route_refreshListing:
	// The ABI return prefix
	byte 0x151f7c75

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute refreshListing(uint64)(uint64,uint64,uint64,byte[13],string)
	callsub refreshListing
	concat
	log
	int 1
	return

// refreshListing(nfdAppID: uint64): Listing
//
// Refreshes a listing in the directory and updates its last touched timestamp.
//
// @param nfdAppID The uint64 application ID of the NFD that will be refreshed
refreshListing:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/AlgoDirectory.algo.ts:112
	// this.checkCallerIsListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: uint64
	callsub checkCallerIsListingOwner

	// contracts/AlgoDirectory.algo.ts:113
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -1 // nfdAppID: uint64
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:114
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -1 // nfdAppID: uint64
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:117
	// oldListingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: uint64
	itob
	frame_bury 0 // storage key//oldListingKey

	// contracts/AlgoDirectory.algo.ts:118
	// newListingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: oldListingKey.vouchAmount,
	//       nfdAppID: oldListingKey.nfdAppID,
	//       tags: oldListingKey.tags,
	//       name: oldListingKey.name,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0027 // initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 24 13
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	int 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // newListingKey: Listing

	// contracts/AlgoDirectory.algo.ts:127
	// this.listings(oldListingKey).delete()
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:130
	// this.listings(newListingKey).value = this.txn.sender
	frame_dig 1 // newListingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:133
	// this.listedNFDappIDs(nfdAppID).value = newListingKey
	frame_dig -1 // nfdAppID: uint64
	itob
	dup
	box_del
	pop
	frame_dig 1 // newListingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:135
	// return newListingKey;
	frame_dig 1 // newListingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// abandonListing(uint64)void
*abi_route_abandonListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute abandonListing(uint64)void
	callsub abandonListing
	int 1
	return

// abandonListing(nfdAppID: uint64): void
//
// Abandons a listing in the directory and returns the vouched collateral.
//
// @param nfdAppID The uint64 application ID of the NFD that will be abandoned
abandonListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:144
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: uint64
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:145
	// this.checkCallerIsListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: uint64
	callsub checkCallerIsListingOwner

	// contracts/AlgoDirectory.algo.ts:148
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.listings(listingKey).value,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:149
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:150
	// receiver: this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:151
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:152
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:156
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:157
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: uint64
	itob
	box_del
	retsub

// deleteListing(uint64)void
*abi_route_deleteListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute deleteListing(uint64)void
	callsub deleteListing
	int 1
	return

// deleteListing(nfdAppID: uint64): void
//
// Deletes a listing from the directory & sends the collateral to the fee sink.
//
// @param nfdAppID The uint64 application ID of the NFD that will be deleted
deleteListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:167
	// verifyAppCallTxn(this.txn, { sender: globals.creatorAddress })
	// verify sender
	txn Sender
	global CreatorAddress
	==

	// transaction verification failed: {"txn":"this.txn","field":"sender","expected":"globals.creatorAddress"}
	assert

	// contracts/AlgoDirectory.algo.ts:169
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: uint64
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:172
	// this.listedNFDappIDs(listingKey.nfdAppID).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	box_del

	// contracts/AlgoDirectory.algo.ts:173
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:176
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: Address.fromAddress('Y76M3MSY6DKBRHBL7C3NNDXGS5IIMQVQVUAB6MP4XEMMGVF2QWNPL226CA'), // Fee sink
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:177
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:178
	// receiver: Address.fromAddress('Y76M3MSY6DKBRHBL7C3NNDXGS5IIMQVQVUAB6MP4XEMMGVF2QWNPL226CA')
	addr Y76M3MSY6DKBRHBL7C3NNDXGS5IIMQVQVUAB6MP4XEMMGVF2QWNPL226CA
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:179
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:180
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0
	retsub

// updateApplication()void
*abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	int 1
	return

// updateApplication(): void
updateApplication:
	proto 0 0

	// contracts/AlgoDirectory.algo.ts:187
	// assert(this.txn.sender === this.app.creator, 'Only the creator can update the application')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can update the application
	assert
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)"
	method "refreshListing(uint64)(uint64,uint64,uint64,byte[13],string)"
	method "abandonListing(uint64)void"
	method "deleteListing(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createListing *abi_route_refreshListing *abi_route_abandonListing *abi_route_deleteListing

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	method "updateApplication()void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub