#pragma version 10

// This TEAL was generated by TEALScript v0.102.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following lines of TEAL are used to initialize template variables in scratch slots
pushbytes TMPL_nfdRegistryAppID
btoi
store 202
pushbytes TMPL_directoryAppID
btoi
store 201
pushbytes TMPL_feeSinkAddress
store 200

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// checkCallerIsListingOwner(nfdAppID: AppID): void
checkCallerIsListingOwner:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:31
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:32
	// assert(this.txn.sender === this.listings(listingKey).value, 'Caller must be listing owner')
	txn Sender
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	==

	// Caller must be listing owner
	assert
	retsub

// checkNFDIsSegmentOfDirectory(nfdAppID: AppID): void
checkNFDIsSegmentOfDirectory:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:37
	// assert(
	//       btoi(nfdAppID.globalState('i.parentAppID') as bytes) === this.directoryAppID.id,
	//       'NFD must be a segment of directory.algo'
	//     )
	frame_dig -1 // nfdAppID: AppID
	byte 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.parentAppID')
	assert
	btoi
	load 201 // TMPL_directoryAppID
	==

	// NFD must be a segment of directory.algo
	assert
	retsub

// checkCallerIsNFDOwner(nfdAppID: AppID): void
checkCallerIsNFDOwner:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:45
	// assert(
	//       this.txn.sender === (nfdAppID.globalState('i.owner.a') as Address),
	//       'Listing creator must be the NFD app i.owner.a'
	//     )
	txn Sender
	frame_dig -1 // nfdAppID: AppID
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.owner.a')
	assert
	==

	// Listing creator must be the NFD app i.owner.a
	assert
	retsub

// checkNFDNotExpired(nfdAppID: AppID): void
checkNFDNotExpired:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:53
	// assert(
	//       globals.latestTimestamp <= btoi(nfdAppID.globalState('i.expirationTime') as bytes),
	//       'NFD segment must not be expired'
	//     )
	global LatestTimestamp
	frame_dig -1 // nfdAppID: AppID
	byte 0x692e65787069726174696f6e54696d65 // "i.expirationTime"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.expirationTime')
	assert
	btoi
	<=

	// NFD segment must not be expired
	assert
	retsub

// getRoundedTimestamp(): uint64
getRoundedTimestamp:
	proto 0 1

	// contracts/AlgoDirectory.algo.ts:60
	// return btoi(replace3(itob(globals.latestTimestamp), 7, bzero(1)));
	global LatestTimestamp
	itob
	byte 0x00
	replace2 7
	btoi
	retsub

// createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
*abi_route_createListing:
	// The ABI return prefix
	byte 0x151f7c75

	// listingTags: byte[13]
	txna ApplicationArgs 2
	dup
	len
	int 13
	==

	// argument 0 (listingTags) for createListing must be a byte[13]
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// collateralPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==

	// argument 2 (collateralPayment) for createListing must be a pay transaction
	assert

	// execute createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
	callsub createListing
	concat
	log
	int 1
	return

// createListing(collateralPayment: PayTxn, nfdAppID: AppID, listingTags: StaticArray<byte, 13>): Listing
//
// Creates a listing in the directory by vouching for an NFD root or segment of directory.algo.
//
// @param collateralPayment The Algo payment of collateral to vouch for the listing
// @param nfdAppID The uint64 application ID of the NFD that will be listed
// @param listingTags Array of 13 bytes each representing a tag for the listing
createListing:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/AlgoDirectory.algo.ts:72
	// verifyPayTxn(collateralPayment, {
	//       sender: this.txn.sender,
	//       receiver: this.app.address,
	//       amount: { greaterThanEqualTo: TOTAL_LISTING_BOXES_COST },
	//     })
	// verify sender
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"sender","expected":"this.txn.sender"}
	assert

	// verify receiver
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	int 72200
	>=

	// transaction verification failed: {"txn":"collateralPayment","field":"amount","condition":"greaterThanEqualTo","expected":">=TOTAL_LISTING_BOXES_COST"}
	assert

	// contracts/AlgoDirectory.algo.ts:79
	// this.checkNFDIsSegmentOfDirectory(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDIsSegmentOfDirectory

	// contracts/AlgoDirectory.algo.ts:80
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:81
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:84
	// nfdLongName = nfdAppID.globalState('i.name') as bytes
	frame_dig -2 // nfdAppID: AppID
	byte 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.name')
	assert
	frame_bury 0 // nfdLongName: byte[]

	// contracts/AlgoDirectory.algo.ts:86
	// sendAppCall({
	//       applicationID: this.nfdRegistryAppID,
	//       applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)],
	//       fee: 0,
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:87
	// applicationID: this.nfdRegistryAppID
	load 202 // TMPL_nfdRegistryAppID
	itxn_field ApplicationID

	// contracts/AlgoDirectory.algo.ts:88
	// applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)]
	byte 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig 0 // nfdLongName: byte[]
	itxn_field ApplicationArgs
	frame_dig -2 // nfdAppID: AppID
	itob
	itxn_field ApplicationArgs

	// contracts/AlgoDirectory.algo.ts:89
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:91
	// assert(btoi(this.itxn.lastLog) === 1, 'NFD app ID must be valid at the NFD registry')
	itxn LastLog
	btoi
	int 1
	==

	// NFD app ID must be valid at the NFD registry
	assert

	// contracts/AlgoDirectory.algo.ts:94
	// assert(!this.listedNFDappIDs(nfdAppID).exists, 'Listing for this NFD must not already exist')
	frame_dig -2 // nfdAppID: AppID
	itob
	box_len
	swap
	pop
	!

	// Listing for this NFD must not already exist
	assert

	// contracts/AlgoDirectory.algo.ts:97
	// nfdSegmentName = substring3(nfdLongName, 0, len(nfdLongName) - 15)
	frame_dig 0 // nfdLongName: byte[]
	int 0
	frame_dig 0 // nfdLongName: byte[]
	len
	int 15
	-
	substring3
	frame_bury 1 // nfdSegmentName: byte[]

	// contracts/AlgoDirectory.algo.ts:99
	// listingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: collateralPayment.amount,
	//       nfdAppID: nfdAppID,
	//       tags: listingTags,
	//       name: nfdSegmentName,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0027 // initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // nfdAppID: AppID
	itob
	callsub *process_static_tuple_element
	frame_dig -3 // listingTags: StaticArray<byte, 13>
	callsub *process_static_tuple_element
	frame_dig 1 // nfdSegmentName: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // listingKey: Listing

	// contracts/AlgoDirectory.algo.ts:108
	// this.listings(listingKey).value = this.txn.sender
	frame_dig 2 // listingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:111
	// this.listedNFDappIDs(nfdAppID).value = listingKey
	frame_dig -2 // nfdAppID: AppID
	itob
	dup
	box_del
	pop
	frame_dig 2 // listingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:113
	// return listingKey;
	frame_dig 2 // listingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// refreshListing(uint64)(uint64,uint64,uint64,byte[13],string)
*abi_route_refreshListing:
	// The ABI return prefix
	byte 0x151f7c75

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute refreshListing(uint64)(uint64,uint64,uint64,byte[13],string)
	callsub refreshListing
	concat
	log
	int 1
	return

// refreshListing(nfdAppID: AppID): Listing
//
// Refreshes a listing in the directory and updates its last touched timestamp.
//
// @param nfdAppID The uint64 application ID of the NFD that will be refreshed
refreshListing:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/AlgoDirectory.algo.ts:123
	// this.checkCallerIsListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsListingOwner

	// contracts/AlgoDirectory.algo.ts:124
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:125
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:128
	// oldListingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//oldListingKey

	// contracts/AlgoDirectory.algo.ts:129
	// newListingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: oldListingKey.vouchAmount,
	//       nfdAppID: oldListingKey.nfdAppID,
	//       tags: oldListingKey.tags,
	//       name: oldListingKey.name,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0027 // initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 24 13
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	int 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // newListingKey: Listing

	// contracts/AlgoDirectory.algo.ts:138
	// this.listings(oldListingKey).delete()
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:141
	// this.listings(newListingKey).value = this.txn.sender
	frame_dig 1 // newListingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:144
	// this.listedNFDappIDs(nfdAppID).value = newListingKey
	frame_dig -1 // nfdAppID: AppID
	itob
	dup
	box_del
	pop
	frame_dig 1 // newListingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:146
	// return newListingKey;
	frame_dig 1 // newListingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// abandonListing(uint64)void
*abi_route_abandonListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute abandonListing(uint64)void
	callsub abandonListing
	int 1
	return

// abandonListing(nfdAppID: AppID): void
//
// Abandons a listing in the directory and returns the vouched collateral.
//
// @param nfdAppID The uint64 application ID of the NFD that will be abandoned
abandonListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:155
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:156
	// this.checkCallerIsListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsListingOwner

	// contracts/AlgoDirectory.algo.ts:159
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.listings(listingKey).value,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:160
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:161
	// receiver: this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:162
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:163
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:167
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:168
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del
	retsub

// deleteListing(uint64)void
*abi_route_deleteListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute deleteListing(uint64)void
	callsub deleteListing
	int 1
	return

// deleteListing(nfdAppID: AppID): void
//
// Deletes a listing from the directory & sends the collateral to the fee sink.
//
// @param nfdAppID The uint64 application ID of the NFD that will be deleted
deleteListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:178
	// assert(this.txn.sender.assetBalance(this.adminToken.value) > 0, 'Caller must have the admin token')
	txn Sender
	byte 0x61646d696e546f6b656e // "adminToken"
	app_global_get
	asset_holding_get AssetBalance
	pop
	int 0
	>

	// Caller must have the admin token
	assert

	// contracts/AlgoDirectory.algo.ts:180
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:183
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.feeSinkAddress,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//       note: 'Yeeted ' + listingKey.name + ' to the fee sink',
	//     })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:184
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:185
	// receiver: this.feeSinkAddress
	load 200 // TMPL_feeSinkAddress
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:186
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:187
	// fee: 0
	int 0
	itxn_field Fee

	// contracts/AlgoDirectory.algo.ts:188
	// note: 'Yeeted ' + listingKey.name + ' to the fee sink'
	byte 0x59656574656420 // "Yeeted "
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	int 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	concat
	byte 0x20746f20746865206665652073696e6b // " to the fee sink"
	concat
	itxn_field Note

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:192
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:193
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del
	retsub

// setAdminToken(uint64)void
*abi_route_setAdminToken:
	// asaID: uint64
	txna ApplicationArgs 1
	btoi

	// execute setAdminToken(uint64)void
	callsub setAdminToken
	int 1
	return

// setAdminToken(asaID: AssetID): void
//
// Stores an ASA ID in global state that will control administration rights
//
// @param asaID The uint64 asset ID of the ASA to be the admin token
setAdminToken:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:202
	// assert(this.txn.sender === this.app.creator, 'Only the creator can set the admin token')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can set the admin token
	assert

	// contracts/AlgoDirectory.algo.ts:203
	// this.adminToken.value = asaID
	byte 0x61646d696e546f6b656e // "adminToken"
	frame_dig -1 // asaID: AssetID
	app_global_put
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0
	retsub

// updateApplication()void
*abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	int 1
	return

// updateApplication(): void
updateApplication:
	proto 0 0

	// contracts/AlgoDirectory.algo.ts:209
	// assert(this.txn.sender === this.app.creator, 'Only the creator can update the application')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can update the application
	assert
	retsub

*create_NoOp:
	method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)"
	method "refreshListing(uint64)(uint64,uint64,uint64,byte[13],string)"
	method "abandonListing(uint64)void"
	method "deleteListing(uint64)void"
	method "setAdminToken(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createListing *abi_route_refreshListing *abi_route_abandonListing *abi_route_deleteListing *abi_route_setAdminToken

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	method "updateApplication()void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub