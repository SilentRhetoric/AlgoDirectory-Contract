#pragma version 10
intcblock TMPL_nfdRegistryAppID TMPL_directoryAppID 1
bytecblock TMPL_feeSinkAddress 0x 0x61646d696e546f6b656e 0x692e6f776e65722e61 0x151f7c75 0x0002 0x0027

// This TEAL was generated by TEALScript v0.104.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following lines of TEAL are used to initialize template variables in scratch slots
intc 0 // TMPL_nfdRegistryAppID
intc 1 // TMPL_directoryAppID
bytec 0 // TMPL_feeSinkAddress

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
pushint 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// checkCallerIsListingOwner(nfdAppID: AppID): void
checkCallerIsListingOwner:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:38
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:39
	// assert(this.txn.sender === this.listings(listingKey).value, 'Caller must be listing owner')
	txn Sender
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	==

	// Caller must be listing owner
	assert
	retsub

// checkNFDIsSegmentOfDirectory(nfdAppID: AppID): void
checkNFDIsSegmentOfDirectory:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:44
	// assert(
	//       btoi(nfdAppID.globalState('i.parentAppID') as bytes) === this.directoryAppID.id,
	//       'NFD must be a segment of directory.algo'
	//     )
	frame_dig -1 // nfdAppID: AppID
	pushbytes 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.parentAppID')
	assert
	btoi
	intc 1 // TMPL_directoryAppID
	==

	// NFD must be a segment of directory.algo
	assert
	retsub

// checkCallerIsNFDOwner(nfdAppID: AppID): void
checkCallerIsNFDOwner:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:52
	// assert(
	//       this.txn.sender === (nfdAppID.globalState('i.owner.a') as Address),
	//       'Listing creator must be the NFD app i.owner.a'
	//     )
	txn Sender
	frame_dig -1 // nfdAppID: AppID
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.owner.a')
	assert
	==

	// Listing creator must be the NFD app i.owner.a
	assert
	retsub

// checkNFDOwnerIsNotListingOwner(nfdAppID: AppID): void
checkNFDOwnerIsNotListingOwner:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/AlgoDirectory.algo.ts:60
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:61
	// listingOwner = this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	frame_bury 1 // listingOwner: address

	// contracts/AlgoDirectory.algo.ts:63
	// nfdOwner = nfdAppID.globalState('i.owner.a') as Address
	frame_dig -1 // nfdAppID: AppID
	byte 0x692e6f776e65722e61 // "i.owner.a"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.owner.a')
	assert
	frame_bury 2 // nfdOwner: address

	// contracts/AlgoDirectory.algo.ts:65
	// assert(nfdOwner !== listingOwner, 'NFD owner must be different than the listing owner')
	frame_dig 2 // nfdOwner: address
	frame_dig 1 // listingOwner: address
	!=

	// NFD owner must be different than the listing owner
	assert
	retsub

// checkNFDNotExpired(nfdAppID: AppID): void
checkNFDNotExpired:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:71
	// assert(
	//       globals.latestTimestamp <= btoi(nfdAppID.globalState('i.expirationTime') as bytes),
	//       'NFD segment must not be expired'
	//     )
	global LatestTimestamp
	frame_dig -1 // nfdAppID: AppID
	pushbytes 0x692e65787069726174696f6e54696d65 // "i.expirationTime"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.expirationTime')
	assert
	btoi
	<=

	// NFD segment must not be expired
	assert
	retsub

// checkNFDNotForSale(nfdAppID: AppID): void
checkNFDNotForSale:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:80
	// assert(!nfdAppID.globalStateExists('i.sellamt'), 'NFD segment must not be listed for sale')
	frame_dig -1 // nfdAppID: AppID
	pushbytes 0x692e73656c6c616d74 // "i.sellamt"
	app_global_get_ex
	swap
	pop
	!

	// NFD segment must not be listed for sale
	assert
	retsub

// getRoundedTimestamp(): uint64
getRoundedTimestamp:
	proto 0 1

	// contracts/AlgoDirectory.algo.ts:84
	// return btoi(replace3(itob(globals.latestTimestamp), 7, bzero(1)));
	global LatestTimestamp
	itob
	pushbytes 0x00
	replace2 7
	btoi
	retsub

// createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
*abi_route_createListing:
	// The ABI return prefix
	byte 0x151f7c75

	// listingTags: byte[13]
	txna ApplicationArgs 2
	dup
	len
	pushint 13
	==

	// argument 0 (listingTags) for createListing must be a byte[13]
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// collateralPayment: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int 1 // pay
	==

	// argument 2 (collateralPayment) for createListing must be a pay transaction
	assert

	// execute createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
	callsub createListing
	concat
	log
	int 1
	return

// createListing(collateralPayment: PayTxn, nfdAppID: AppID, listingTags: StaticArray<byte, 13>): Listing
//
// Creates a listing in the directory by vouching for an NFD root or segment of directory.algo
//
// @param collateralPayment The Algo payment transaction of collateral to vouch for the listing
// @param nfdAppID The Application ID of the NFD that will be listed
// @param listingTags An array of 13 bytes with each representing a tag for the listing
createListing:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/AlgoDirectory.algo.ts:104
	// verifyPayTxn(collateralPayment, {
	//       sender: this.txn.sender,
	//       receiver: this.app.address,
	//       amount: { greaterThanEqualTo: TOTAL_LISTING_BOXES_COST },
	//     })
	// verify sender
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"sender","expected":"this.txn.sender"}
	assert

	// verify receiver
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	pushint 72200
	>=

	// transaction verification failed: {"txn":"collateralPayment","field":"amount","condition":"greaterThanEqualTo","expected":">=TOTAL_LISTING_BOXES_COST"}
	assert

	// contracts/AlgoDirectory.algo.ts:111
	// this.checkNFDIsSegmentOfDirectory(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDIsSegmentOfDirectory

	// contracts/AlgoDirectory.algo.ts:112
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:113
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:114
	// this.checkNFDNotForSale(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDNotForSale

	// contracts/AlgoDirectory.algo.ts:117
	// nfdLongName = nfdAppID.globalState('i.name') as bytes
	frame_dig -2 // nfdAppID: AppID
	pushbytes 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.name')
	assert
	frame_bury 0 // nfdLongName: byte[]

	// contracts/AlgoDirectory.algo.ts:119
	// sendAppCall({
	//       applicationID: this.nfdRegistryAppID,
	//       applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)],
	//       fee: 0,
	//     })
	itxn_begin
	pushint 6 // appl
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:120
	// applicationID: this.nfdRegistryAppID
	intc 0 // TMPL_nfdRegistryAppID
	itxn_field ApplicationID

	// contracts/AlgoDirectory.algo.ts:121
	// applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)]
	pushbytes 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig 0 // nfdLongName: byte[]
	itxn_field ApplicationArgs
	frame_dig -2 // nfdAppID: AppID
	itob
	itxn_field ApplicationArgs

	// contracts/AlgoDirectory.algo.ts:122
	// fee: 0
	pushint 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:124
	// assert(btoi(this.itxn.lastLog) === 1, 'NFD app ID must be valid at the NFD registry')
	itxn LastLog
	btoi
	int 1
	==

	// NFD app ID must be valid at the NFD registry
	assert

	// contracts/AlgoDirectory.algo.ts:127
	// assert(!this.listedNFDappIDs(nfdAppID).exists, 'Listing for this NFD must not already exist')
	frame_dig -2 // nfdAppID: AppID
	itob
	box_len
	swap
	pop
	!

	// Listing for this NFD must not already exist
	assert

	// contracts/AlgoDirectory.algo.ts:130
	// nfdSegmentName = substring3(nfdLongName, 0, len(nfdLongName) - 15)
	frame_dig 0 // nfdLongName: byte[]
	pushint 0
	frame_dig 0 // nfdLongName: byte[]
	len
	pushint 15
	-
	substring3
	frame_bury 1 // nfdSegmentName: byte[]

	// contracts/AlgoDirectory.algo.ts:132
	// listingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: collateralPayment.amount,
	//       nfdAppID: nfdAppID,
	//       tags: listingTags,
	//       name: nfdSegmentName,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0027 // initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // nfdAppID: AppID
	itob
	callsub *process_static_tuple_element
	frame_dig -3 // listingTags: StaticArray<byte, 13>
	callsub *process_static_tuple_element
	frame_dig 1 // nfdSegmentName: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // listingKey: Listing

	// contracts/AlgoDirectory.algo.ts:141
	// this.listings(listingKey).value = this.txn.sender
	frame_dig 2 // listingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:144
	// this.listedNFDappIDs(nfdAppID).value = listingKey
	frame_dig -2 // nfdAppID: AppID
	itob
	dup
	box_del
	pop
	frame_dig 2 // listingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:147
	// this.CreateListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0x4190737e // CreateListingEvent((uint64,uint64,uint64,byte[13],string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 2 // listingKey: Listing
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:152
	// return listingKey;
	frame_dig 2 // listingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// refreshListing(uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
*abi_route_refreshListing:
	// The ABI return prefix
	byte 0x151f7c75

	// listingTags: byte[13]
	txna ApplicationArgs 2
	dup
	len
	pushint 13
	==

	// argument 0 (listingTags) for refreshListing must be a byte[13]
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute refreshListing(uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
	callsub refreshListing
	concat
	log
	int 1
	return

// refreshListing(nfdAppID: AppID, listingTags: StaticArray<byte, 13>): Listing
//
// Refreshes a listing in the directory and updates its last touched timestamp
//
// @param nfdAppID The Application ID of the NFD that will be refreshed
// @param listingTags An array of 13 bytes with each representing a tag.
// Used to update the tags of the listing, if no tags are to be updated, pass the existing tags
refreshListing:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/AlgoDirectory.algo.ts:176
	// this.checkCallerIsListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsListingOwner

	// contracts/AlgoDirectory.algo.ts:177
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:178
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:179
	// this.checkNFDNotForSale(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDNotForSale

	// contracts/AlgoDirectory.algo.ts:182
	// oldListingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//oldListingKey

	// contracts/AlgoDirectory.algo.ts:183
	// newListingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: oldListingKey.vouchAmount,
	//       nfdAppID: oldListingKey.nfdAppID,
	//       tags: listingTags,
	//       name: oldListingKey.name,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0027 // initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // listingTags: StaticArray<byte, 13>
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	pushint 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	pushint 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // newListingKey: Listing

	// contracts/AlgoDirectory.algo.ts:192
	// this.listings(oldListingKey).delete()
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:195
	// this.listings(newListingKey).value = this.txn.sender
	frame_dig 1 // newListingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:198
	// this.listedNFDappIDs(nfdAppID).value = newListingKey
	frame_dig -1 // nfdAppID: AppID
	itob
	dup
	box_del
	pop
	frame_dig 1 // newListingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:201
	// this.RefreshListingEvent.log({
	//       listing: newListingKey,
	//     })
	pushbytes 0x1fe028d3 // RefreshListingEvent((uint64,uint64,uint64,byte[13],string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 1 // newListingKey: Listing
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:205
	// return newListingKey;
	frame_dig 1 // newListingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// abandonListing(uint64)void
*abi_route_abandonListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute abandonListing(uint64)void
	callsub abandonListing
	int 1
	return

// abandonListing(nfdAppID: AppID): void
//
// Abandons a listing in the directory and returns the vouched collateral
//
// @param nfdAppID The Application ID of the NFD that will be abandoned
abandonListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:221
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:226
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:229
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.listings(listingKey).value,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	int 1 // pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:230
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:231
	// receiver: this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:232
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:233
	// fee: 0
	pushint 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:237
	// this.AbandonListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0x053cc883 // AbandonListingEvent((uint64,uint64,uint64,byte[13],string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:242
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:243
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del
	retsub

// removeTransferredListing(uint64)void
*abi_route_removeTransferredListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeTransferredListing(uint64)void
	callsub removeTransferredListing
	int 1
	return

// removeTransferredListing(nfdAppID: AppID): void
//
// Removes a listing for which the NFD has been transferred.
// Anyone can call this to clean up a listing that is no longer valid.
//
// @param nfdAppID The Application ID of the NFD that will be removed
removeTransferredListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/AlgoDirectory.algo.ts:260
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:263
	// this.checkNFDOwnerIsNotListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDOwnerIsNotListingOwner

	// contracts/AlgoDirectory.algo.ts:266
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.listings(listingKey).value,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	int 1 // pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:267
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:268
	// receiver: this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:269
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:270
	// fee: 0
	pushint 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:274
	// this.RemoveTransferredListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0xbc0cbbd6 // RemoveTransferredListingEvent((uint64,uint64,uint64,byte[13],string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:279
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:280
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del
	retsub

// deleteListingWithPenalty(uint64)string
*abi_route_deleteListingWithPenalty:
	// The ABI return prefix
	byte 0x151f7c75

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute deleteListingWithPenalty(uint64)string
	callsub deleteListingWithPenalty
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// deleteListingWithPenalty(nfdAppID: AppID): string
//
// Deletes a listing from the directory & sends the collateral to the fee sink
//
// @param nfdAppID The Application ID of the NFD that will be deleted
deleteListingWithPenalty:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/AlgoDirectory.algo.ts:297
	// assert(this.txn.sender.assetBalance(this.adminToken.value) > 0, 'Caller must have the admin token')
	txn Sender
	byte 0x61646d696e546f6b656e // "adminToken"
	app_global_get
	asset_holding_get AssetBalance
	pop
	pushint 0
	>

	// Caller must have the admin token
	assert

	// contracts/AlgoDirectory.algo.ts:299
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:300
	// deleteNote = 'Yeeted ' + listingKey.name + ' to the fee sink'
	pushbytes 0x59656574656420 // "Yeeted "
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	pushint 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	pushint 2
	+ // add two for length
	extract3
	extract 2 0
	concat
	pushbytes 0x20746f20746865206665652073696e6b // " to the fee sink"
	concat
	frame_bury 1 // deleteNote: byte[]

	// contracts/AlgoDirectory.algo.ts:303
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.feeSinkAddress,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//       note: deleteNote,
	//     })
	itxn_begin
	int 1 // pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:304
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:305
	// receiver: this.feeSinkAddress
	bytec 0 // TMPL_feeSinkAddress
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:306
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:307
	// fee: 0
	pushint 0
	itxn_field Fee

	// contracts/AlgoDirectory.algo.ts:308
	// note: deleteNote
	frame_dig 1 // deleteNote: byte[]
	itxn_field Note

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:312
	// this.DeleteListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0x172e4394 // DeleteListingEvent((uint64,uint64,uint64,byte[13],string))
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0002 // initial head offset
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:317
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:318
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del

	// contracts/AlgoDirectory.algo.ts:320
	// return deleteNote;
	frame_dig 1 // deleteNote: byte[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// setAdminToken(uint64)void
*abi_route_setAdminToken:
	// asaID: uint64
	txna ApplicationArgs 1
	btoi

	// execute setAdminToken(uint64)void
	callsub setAdminToken
	int 1
	return

// setAdminToken(asaID: AssetID): void
//
// Stores an ASA ID in global state that will control administration rights
//
// @param asaID The Asset ID of the ASA to be the admin token
setAdminToken:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:329
	// assert(this.txn.sender === this.app.creator, 'Only the creator can set the admin token')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can set the admin token
	assert

	// contracts/AlgoDirectory.algo.ts:330
	// this.adminToken.value = asaID
	byte 0x61646d696e546f6b656e // "adminToken"
	frame_dig -1 // asaID: AssetID
	app_global_put
	retsub

// updateApplication()void
*abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	int 1
	return

// updateApplication(): void
//
// Enables the application to be updated by the creator
updateApplication:
	proto 0 0

	// contracts/AlgoDirectory.algo.ts:338
	// assert(this.txn.sender === this.app.creator, 'Only the creator can update the application')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can update the application
	assert
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	int 1
	return

// createApplication(): void
createApplication:
	proto 0 0
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xce88d255 // method "createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)"
	pushbytes 0x106dd2e2 // method "refreshListing(uint64,byte[13])(uint64,uint64,uint64,byte[13],string)"
	pushbytes 0xb29be7b8 // method "abandonListing(uint64)void"
	pushbytes 0x4f900f1d // method "removeTransferredListing(uint64)void"
	pushbytes 0xc65aaa12 // method "deleteListingWithPenalty(uint64)string"
	pushbytes 0x2b2489b7 // method "setAdminToken(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createListing *abi_route_refreshListing *abi_route_abandonListing *abi_route_removeTransferredListing *abi_route_deleteListingWithPenalty *abi_route_setAdminToken

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x46f76533 // method "updateApplication()void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub