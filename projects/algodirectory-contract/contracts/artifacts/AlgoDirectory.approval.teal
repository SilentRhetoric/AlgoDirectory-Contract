#pragma version 10
intcblock 1 0 2 6 13 37 TMPL_directoryAppID TMPL_nfdRegistryAppID
bytecblock 0x 0x0002 0x151f7c75 0x61646d696e546f6b656e 0x692e6f776e65722e61 0x0027 TMPL_feeSinkAddress

// This TEAL was generated by TEALScript v0.105.4
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 3 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// checkCallerIsListingOwner(nfdAppID: AppID): void
checkCallerIsListingOwner:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/AlgoDirectory.algo.ts:36
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:37
	// assert(this.txn.sender === this.listings(listingKey).value, 'Caller must be listing owner')
	txn Sender
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	==

	// Caller must be listing owner
	assert
	retsub

// checkNFDIsSegmentOfDirectory(nfdAppID: AppID): void
checkNFDIsSegmentOfDirectory:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:42
	// assert(
	//       btoi(nfdAppID.globalState('i.parentAppID') as bytes) === this.directoryAppID.id,
	//       'NFD must be a segment of directory.algo'
	//     )
	frame_dig -1 // nfdAppID: AppID
	pushbytes 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.parentAppID')
	assert
	btoi
	intc 6 // TMPL_directoryAppID
	==

	// NFD must be a segment of directory.algo
	assert
	retsub

// checkCallerIsNFDOwner(nfdAppID: AppID): void
checkCallerIsNFDOwner:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:50
	// assert(
	//       this.txn.sender === (nfdAppID.globalState('i.owner.a') as Address),
	//       'Listing creator must be the NFD app i.owner.a'
	//     )
	txn Sender
	frame_dig -1 // nfdAppID: AppID
	bytec 4 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.owner.a')
	assert
	==

	// Listing creator must be the NFD app i.owner.a
	assert
	retsub

// checkNFDOwnerIsNotListingOwner(nfdAppID: AppID): void
checkNFDOwnerIsNotListingOwner:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/AlgoDirectory.algo.ts:58
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:59
	// listingOwner = this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	frame_bury 1 // listingOwner: address

	// contracts/AlgoDirectory.algo.ts:61
	// nfdOwner = nfdAppID.globalState('i.owner.a') as Address
	frame_dig -1 // nfdAppID: AppID
	bytec 4 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.owner.a')
	assert
	frame_bury 2 // nfdOwner: address

	// contracts/AlgoDirectory.algo.ts:63
	// assert(nfdOwner !== listingOwner, 'NFD owner must be different than the listing owner')
	frame_dig 2 // nfdOwner: address
	frame_dig 1 // listingOwner: address
	!=

	// NFD owner must be different than the listing owner
	assert
	retsub

// checkNFDNotExpired(nfdAppID: AppID): void
checkNFDNotExpired:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:69
	// assert(
	//       globals.latestTimestamp <= btoi(nfdAppID.globalState('i.expirationTime') as bytes),
	//       'NFD segment must not be expired'
	//     )
	global LatestTimestamp
	frame_dig -1 // nfdAppID: AppID
	pushbytes 0x692e65787069726174696f6e54696d65 // "i.expirationTime"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.expirationTime')
	assert
	btoi
	<=

	// NFD segment must not be expired
	assert
	retsub

// checkNFDNotForSale(nfdAppID: AppID): void
checkNFDNotForSale:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:78
	// assert(!nfdAppID.globalStateExists('i.sellamt'), 'NFD segment must not be listed for sale')
	frame_dig -1 // nfdAppID: AppID
	pushbytes 0x692e73656c6c616d74 // "i.sellamt"
	app_global_get_ex
	swap
	pop
	!

	// NFD segment must not be listed for sale
	assert
	retsub

// getRoundedTimestamp(): uint64
getRoundedTimestamp:
	proto 0 1

	// contracts/AlgoDirectory.algo.ts:82
	// return btoi(replace3(itob(globals.latestTimestamp), 7, bzero(1)));
	global LatestTimestamp
	itob
	pushbytes 0x00
	replace2 7
	btoi
	retsub

// createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
*abi_route_createListing:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// listingTags: byte[13]
	txna ApplicationArgs 2
	dup
	len
	intc 4 // 13
	==

	// argument 0 (listingTags) for createListing must be a byte[13]
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// collateralPayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 2 (collateralPayment) for createListing must be a pay transaction
	assert

	// execute createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
	callsub createListing
	concat
	log
	intc 0 // 1
	return

// createListing(collateralPayment: PayTxn, nfdAppID: AppID, listingTags: StaticArray<byte, 13>): Listing
//
// Creates a listing in the directory by vouching for an NFD root or segment of directory.algo
//
// @param collateralPayment The Algo payment transaction of collateral to vouch for the listing
// @param nfdAppID The Application ID of the NFD that will be listed
// @param listingTags An array of 13 bytes with each representing a tag for the listing
createListing:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/AlgoDirectory.algo.ts:102
	// verifyPayTxn(collateralPayment, {
	//       sender: this.txn.sender,
	//       receiver: this.app.address,
	//       amount: { greaterThanEqualTo: TOTAL_LISTING_BOXES_COST },
	//     })
	// verify sender
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"sender","expected":"this.txn.sender"}
	assert

	// verify receiver
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"collateralPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	pushint 72200
	>=

	// transaction verification failed: {"txn":"collateralPayment","field":"amount","condition":"greaterThanEqualTo","expected":">=TOTAL_LISTING_BOXES_COST"}
	assert

	// contracts/AlgoDirectory.algo.ts:109
	// this.checkNFDIsSegmentOfDirectory(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDIsSegmentOfDirectory

	// contracts/AlgoDirectory.algo.ts:110
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:111
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:112
	// this.checkNFDNotForSale(nfdAppID)
	frame_dig -2 // nfdAppID: AppID
	callsub checkNFDNotForSale

	// contracts/AlgoDirectory.algo.ts:115
	// nfdLongName = nfdAppID.globalState('i.name') as bytes
	frame_dig -2 // nfdAppID: AppID
	pushbytes 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: nfdAppID.globalState('i.name')
	assert
	frame_bury 0 // nfdLongName: byte[]

	// contracts/AlgoDirectory.algo.ts:117
	// sendAppCall({
	//       applicationID: this.nfdRegistryAppID,
	//       applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)],
	//       fee: 0,
	//     })
	itxn_begin
	intc 3 //  appl
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:118
	// applicationID: this.nfdRegistryAppID
	intc 7 // TMPL_nfdRegistryAppID
	itxn_field ApplicationID

	// contracts/AlgoDirectory.algo.ts:119
	// applicationArgs: ['is_valid_nfd_appid', nfdLongName, itob(nfdAppID)]
	pushbytes 0x69735f76616c69645f6e66645f6170706964 // "is_valid_nfd_appid"
	itxn_field ApplicationArgs
	frame_dig 0 // nfdLongName: byte[]
	itxn_field ApplicationArgs
	frame_dig -2 // nfdAppID: AppID
	itob
	itxn_field ApplicationArgs

	// contracts/AlgoDirectory.algo.ts:120
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:122
	// assert(btoi(this.itxn.lastLog) === 1, 'NFD app ID must be valid at the NFD registry')
	itxn LastLog
	btoi
	intc 0 // 1
	==

	// NFD app ID must be valid at the NFD registry
	assert

	// contracts/AlgoDirectory.algo.ts:125
	// assert(!this.listedNFDappIDs(nfdAppID).exists, 'Listing for this NFD must not already exist')
	frame_dig -2 // nfdAppID: AppID
	itob
	box_len
	swap
	pop
	!

	// Listing for this NFD must not already exist
	assert

	// contracts/AlgoDirectory.algo.ts:128
	// nfdSegmentName = substring3(nfdLongName, 0, len(nfdLongName) - 15)
	frame_dig 0 // nfdLongName: byte[]
	intc 1 // 0
	frame_dig 0 // nfdLongName: byte[]
	len
	pushint 15
	-
	substring3
	frame_bury 1 // nfdSegmentName: byte[]

	// contracts/AlgoDirectory.algo.ts:130
	// listingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: collateralPayment.amount,
	//       nfdAppID: nfdAppID,
	//       tags: listingTags,
	//       name: nfdSegmentName,
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 5 //  initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig -1 // collateralPayment: PayTxn
	gtxns Amount
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // nfdAppID: AppID
	itob
	callsub *process_static_tuple_element
	frame_dig -3 // listingTags: StaticArray<byte, 13>
	callsub *process_static_tuple_element
	frame_dig 1 // nfdSegmentName: byte[]
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 2 // listingKey: Listing

	// contracts/AlgoDirectory.algo.ts:139
	// this.listings(listingKey).value = this.txn.sender
	frame_dig 2 // listingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:142
	// this.listedNFDappIDs(nfdAppID).value = listingKey
	frame_dig -2 // nfdAppID: AppID
	itob
	dup
	box_del
	pop
	frame_dig 2 // listingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:145
	// this.CreateListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0x4190737e // CreateListingEvent((uint64,uint64,uint64,byte[13],string))
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig 2 // listingKey: Listing
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:150
	// return listingKey;
	frame_dig 2 // listingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// refreshListing(uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
*abi_route_refreshListing:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// listingTags: byte[13]
	txna ApplicationArgs 2
	dup
	len
	intc 4 // 13
	==

	// argument 0 (listingTags) for refreshListing must be a byte[13]
	assert

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute refreshListing(uint64,byte[13])(uint64,uint64,uint64,byte[13],string)
	callsub refreshListing
	concat
	log
	intc 0 // 1
	return

// refreshListing(nfdAppID: AppID, listingTags: StaticArray<byte, 13>): Listing
//
// Refreshes a listing in the directory and updates its last touched timestamp
//
// @param nfdAppID The Application ID of the NFD that will be refreshed
// @param listingTags An array of 13 bytes with each representing a tag; used to update the tags of the listing, if no tags are to be updated, pass the existing tags
refreshListing:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/AlgoDirectory.algo.ts:173
	// this.checkCallerIsListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsListingOwner

	// contracts/AlgoDirectory.algo.ts:174
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:175
	// this.checkNFDNotExpired(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDNotExpired

	// contracts/AlgoDirectory.algo.ts:176
	// this.checkNFDNotForSale(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDNotForSale

	// contracts/AlgoDirectory.algo.ts:179
	// oldListingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//oldListingKey

	// contracts/AlgoDirectory.algo.ts:180
	// newListingKey: Listing = {
	//       timestamp: this.getRoundedTimestamp(), // Round the timestamp
	//       vouchAmount: oldListingKey.vouchAmount,
	//       nfdAppID: oldListingKey.nfdAppID,
	//       tags: listingTags,
	//       name: oldListingKey.name,
	//     }
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 5 //  initial head offset
	callsub getRoundedTimestamp
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 16 8
	btoi
	itob
	callsub *process_static_tuple_element
	frame_dig -2 // listingTags: StaticArray<byte, 13>
	callsub *process_static_tuple_element
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	intc 5 // 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 0 //  get type length
	* // multiply by type length
	intc 2 // 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 1 // newListingKey: Listing

	// contracts/AlgoDirectory.algo.ts:189
	// this.listings(oldListingKey).delete()
	frame_dig 0 // storage key//oldListingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:192
	// this.listings(newListingKey).value = this.txn.sender
	frame_dig 1 // newListingKey: Listing
	txn Sender
	box_put

	// contracts/AlgoDirectory.algo.ts:195
	// this.listedNFDappIDs(nfdAppID).value = newListingKey
	frame_dig -1 // nfdAppID: AppID
	itob
	dup
	box_del
	pop
	frame_dig 1 // newListingKey: Listing
	box_put

	// contracts/AlgoDirectory.algo.ts:198
	// this.RefreshListingEvent.log({
	//       listing: newListingKey,
	//     })
	pushbytes 0x1fe028d3 // RefreshListingEvent((uint64,uint64,uint64,byte[13],string))
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig 1 // newListingKey: Listing
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:202
	// return newListingKey;
	frame_dig 1 // newListingKey: Listing

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// abandonListing(uint64)void
*abi_route_abandonListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute abandonListing(uint64)void
	callsub abandonListing
	intc 0 // 1
	return

// abandonListing(nfdAppID: AppID): void
//
// Abandons a listing in the directory and returns the vouched collateral
//
// @param nfdAppID The Application ID of the NFD that will be abandoned
abandonListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/AlgoDirectory.algo.ts:218
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:223
	// this.checkCallerIsNFDOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkCallerIsNFDOwner

	// contracts/AlgoDirectory.algo.ts:226
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.listings(listingKey).value,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:227
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:228
	// receiver: this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:229
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:230
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:234
	// this.AbandonListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0x053cc883 // AbandonListingEvent((uint64,uint64,uint64,byte[13],string))
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:239
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:240
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del
	retsub

// removeTransferredListing(uint64)void
*abi_route_removeTransferredListing:
	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute removeTransferredListing(uint64)void
	callsub removeTransferredListing
	intc 0 // 1
	return

// removeTransferredListing(nfdAppID: AppID): void
//
// Removes a listing for which the NFD has been transferred.
// Anyone can call this to clean up a listing that is no longer valid.
//
// @param nfdAppID The Application ID of the NFD that will be removed
removeTransferredListing:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/AlgoDirectory.algo.ts:257
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:260
	// this.checkNFDOwnerIsNotListingOwner(nfdAppID)
	frame_dig -1 // nfdAppID: AppID
	callsub checkNFDOwnerIsNotListingOwner

	// contracts/AlgoDirectory.algo.ts:263
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.listings(listingKey).value,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:264
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:265
	// receiver: this.listings(listingKey).value
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_get

	// box value does not exist: this.listings(listingKey).value
	assert
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:266
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:267
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:271
	// this.RemoveTransferredListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0xbc0cbbd6 // RemoveTransferredListingEvent((uint64,uint64,uint64,byte[13],string))
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:276
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:277
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del
	retsub

// deleteListingWithPenalty(uint64)string
*abi_route_deleteListingWithPenalty:
	// The ABI return prefix
	bytec 2 // 0x151f7c75

	// nfdAppID: uint64
	txna ApplicationArgs 1
	btoi

	// execute deleteListingWithPenalty(uint64)string
	callsub deleteListingWithPenalty
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	intc 0 // 1
	return

// deleteListingWithPenalty(nfdAppID: AppID): string
//
// Deletes a listing from the directory & sends the collateral to the fee sink
//
// @param nfdAppID The Application ID of the NFD that will be deleted
deleteListingWithPenalty:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dup

	// contracts/AlgoDirectory.algo.ts:294
	// assert(this.txn.sender.assetBalance(this.adminToken.value) > 0, 'Caller must have the admin token')
	txn Sender
	bytec 3 //  "adminToken"
	app_global_get
	asset_holding_get AssetBalance
	pop
	intc 1 // 0
	>

	// Caller must have the admin token
	assert

	// contracts/AlgoDirectory.algo.ts:296
	// listingKey = this.listedNFDappIDs(nfdAppID).value
	frame_dig -1 // nfdAppID: AppID
	itob
	frame_bury 0 // storage key//listingKey

	// contracts/AlgoDirectory.algo.ts:297
	// deleteNote = 'Yeeted ' + listingKey.name + ' to the fee sink'
	pushbytes 0x59656574656420 // "Yeeted "
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	intc 5 // 37
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	intc 0 //  get type length
	* // multiply by type length
	intc 2 // 2
	+ // add two for length
	extract3
	extract 2 0
	concat
	pushbytes 0x20746f20746865206665652073696e6b // " to the fee sink"
	concat
	frame_bury 1 // deleteNote: byte[]

	// contracts/AlgoDirectory.algo.ts:300
	// sendPayment({
	//       sender: this.app.address,
	//       receiver: this.feeSinkAddress,
	//       amount: listingKey.vouchAmount,
	//       fee: 0,
	//       note: deleteNote,
	//     })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/AlgoDirectory.algo.ts:301
	// sender: this.app.address
	global CurrentApplicationAddress
	itxn_field Sender

	// contracts/AlgoDirectory.algo.ts:302
	// receiver: this.feeSinkAddress
	bytec 6 // TMPL_feeSinkAddress
	itxn_field Receiver

	// contracts/AlgoDirectory.algo.ts:303
	// amount: listingKey.vouchAmount
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	store 255 // full array
	load 255 // full array
	extract 8 8
	btoi
	itxn_field Amount

	// contracts/AlgoDirectory.algo.ts:304
	// fee: 0
	intc 1 // 0
	itxn_field Fee

	// contracts/AlgoDirectory.algo.ts:305
	// note: deleteNote
	frame_dig 1 // deleteNote: byte[]
	itxn_field Note

	// Submit inner transaction
	itxn_submit

	// contracts/AlgoDirectory.algo.ts:309
	// this.DeleteListingEvent.log({
	//       listing: listingKey,
	//     })
	pushbytes 0x172e4394 // DeleteListingEvent((uint64,uint64,uint64,byte[13],string))
	bytec 0 //  initial head
	bytec 0 //  initial tail
	bytec 1 //  initial head offset
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	callsub *process_dynamic_tuple_element
	pop // pop head offset
	concat // concat head and tail
	concat
	log

	// contracts/AlgoDirectory.algo.ts:314
	// this.listings(listingKey).delete()
	frame_dig 0 // storage key//listingKey
	box_get

	// box value does not exist: this.listedNFDappIDs(nfdAppID).value
	assert
	box_del

	// contracts/AlgoDirectory.algo.ts:315
	// this.listedNFDappIDs(nfdAppID).delete()
	frame_dig -1 // nfdAppID: AppID
	itob
	box_del

	// contracts/AlgoDirectory.algo.ts:317
	// return deleteNote;
	frame_dig 1 // deleteNote: byte[]

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 1
	retsub

// setAdminToken(uint64)void
*abi_route_setAdminToken:
	// asaID: uint64
	txna ApplicationArgs 1
	btoi

	// execute setAdminToken(uint64)void
	callsub setAdminToken
	intc 0 // 1
	return

// setAdminToken(asaID: AssetID): void
//
// Stores an ASA ID in global state that will control administration rights
//
// @param asaID The Asset ID of the ASA to be the admin token
setAdminToken:
	proto 1 0

	// contracts/AlgoDirectory.algo.ts:326
	// assert(this.txn.sender === this.app.creator, 'Only the creator can set the admin token')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can set the admin token
	assert

	// contracts/AlgoDirectory.algo.ts:327
	// this.adminToken.value = asaID
	bytec 3 //  "adminToken"
	frame_dig -1 // asaID: AssetID
	app_global_put
	retsub

// updateApplication()void
*abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	intc 0 // 1
	return

// updateApplication(): void
//
// Enables the application to be updated by the creator
updateApplication:
	proto 0 0

	// contracts/AlgoDirectory.algo.ts:335
	// assert(this.txn.sender === this.app.creator, 'Only the creator can update the application')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can update the application
	assert
	retsub

// createApplication()void
*abi_route_createApplication:
	// execute createApplication()void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(): void
createApplication:
	proto 0 0
	retsub

*create_NoOp:
	pushbytes 0xb8447b36 // method "createApplication()void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0xce88d255 // method "createListing(pay,uint64,byte[13])(uint64,uint64,uint64,byte[13],string)"
	pushbytes 0x106dd2e2 // method "refreshListing(uint64,byte[13])(uint64,uint64,uint64,byte[13],string)"
	pushbytes 0xb29be7b8 // method "abandonListing(uint64)void"
	pushbytes 0x4f900f1d // method "removeTransferredListing(uint64)void"
	pushbytes 0xc65aaa12 // method "deleteListingWithPenalty(uint64)string"
	pushbytes 0x2b2489b7 // method "setAdminToken(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_createListing *abi_route_refreshListing *abi_route_abandonListing *abi_route_removeTransferredListing *abi_route_deleteListingWithPenalty *abi_route_setAdminToken

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x46f76533 // method "updateApplication()void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub